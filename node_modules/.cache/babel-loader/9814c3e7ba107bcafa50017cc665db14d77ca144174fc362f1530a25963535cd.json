{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  MockedRequest: () => MockedRequest,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/context/index.ts\nvar context_exports = {};\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n});\n\n// src/context/status.ts\nvar import_codes = __toESM(require(\"statuses/codes.json\"));\nvar status = (statusCode, statusText) => {\n  return res => {\n    res.status = statusCode;\n    res.statusText = statusText || import_codes.default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nvar import_headers_polyfill = require(\"headers-polyfill\");\nfunction set() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return res => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nvar cookieUtils = __toESM(require(\"cookie\"));\nvar cookie = (name, value, options) => {\n  return res => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = value => {\n  return res => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, _ref) => {\n    let [key, rightValue] = _ref;\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/context/json.ts\nvar json = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nvar import_is_node_process = require(\"is-node-process\");\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\nvar delay = durationOrMode => {\n  return res => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n        default:\n          {\n            throw new Error(`Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`);\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`);\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = errorsList => {\n  return res => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nvar import_is_node_process2 = require(\"is-node-process\");\nvar import_headers_polyfill2 = require(\"headers-polyfill\");\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? require(\"node-fetch\") : window.fetch;\nvar augmentRequestInit = requestInit => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return __spreadProps(__spreadValues({}, requestInit), {\n    headers: headers.all()\n  });\n};\nvar createFetchRequestParameters = input => {\n  const {\n    body: body2,\n    method\n  } = input;\n  const requestParameters = __spreadProps(__spreadValues({}, input), {\n    body: void 0\n  });\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = function (input) {\n  let requestInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/setupWorker/setupWorker.ts\nvar import_is_node_process3 = require(\"is-node-process\");\nvar import_strict_event_emitter = require(\"strict-event-emitter\");\n\n// src/setupWorker/start/createStartHandler.ts\nvar import_until4 = require(\"@open-draft/until\");\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar import_until = require(\"@open-draft/until\");\n\n// src/setupWorker/start/utils/getWorkerByRegistration.ts\nvar getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const existingStates = allStates.filter(Boolean);\n  const mockWorker = existingStates.find(worker => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n};\n\n// src/utils/url/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n}\n\n// src/utils/internal/devUtils.ts\nvar import_outvariant = require(\"outvariant\");\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message) {\n  for (var _len4 = arguments.length, positionals = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    positionals[_key4 - 1] = arguments[_key4];\n  }\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n    });\n  }\n  const [error2, instance] = await (0, import_until.until)(async () => {\n    const registration = await navigator.serviceWorker.register(url, options);\n    return [getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  });\n  if (error2) {\n    const isWorkerMissing = error2.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n    }\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", error2.message));\n  }\n  return instance;\n};\n\n// src/setupWorker/start/utils/printStartMessage.ts\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  console.groupEnd();\n}\n\n// src/setupWorker/start/utils/enableMocking.ts\nasync function enableMocking(context, options) {\n  var _a, _b;\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n  if (context.isMockingEnabled) {\n    devUtils.warn(`Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`);\n    return;\n  }\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n}\n\n// src/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event) {\n    for (var _len5 = arguments.length, rest2 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      rest2[_key5 - 1] = arguments[_key5];\n    }\n    const [data2, transfer] = rest2;\n    this.port.postMessage({\n      type: event,\n      data: data2\n    }, {\n      transfer\n    });\n  }\n};\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nvar import_interceptors2 = require(\"@mswjs/interceptors\");\nvar import_headers_polyfill5 = require(\"headers-polyfill\");\n\n// src/utils/request/MockedRequest.ts\nvar cookieUtils3 = __toESM(require(\"cookie\"));\nvar import_cookies = require(\"@mswjs/cookies\");\nvar import_interceptors = require(\"@mswjs/interceptors\");\nvar import_bufferUtils = require(\"@mswjs/interceptors/lib/utils/bufferUtils\");\nvar import_headers_polyfill4 = require(\"headers-polyfill\");\n\n// src/utils/request/getRequestCookies.ts\nvar cookieUtils2 = __toESM(require(\"cookie\"));\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n    default:\n      {\n        return {};\n      }\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nvar import_headers_polyfill3 = require(\"headers-polyfill\");\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split(\"=\");\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest2.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends import_interceptors.IsomorphicRequest {\n  constructor(url) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0, import_bufferUtils.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new import_headers_polyfill4.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n    import_cookies.store.hydrate();\n    const cookiesFromStore = Array.from((_a = import_cookies.store.get(__spreadProps(__spreadValues({}, this), {\n      url: this.url.href\n    }))) == null ? void 0 : _a.entries()).reduce((cookies, _ref2) => {\n      let [name, {\n        value\n      }] = _ref2;\n      return Object.assign(cookies, {\n        [name.trim()]: value\n      });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = __spreadValues(__spreadValues({}, cookiesFromDocument), cookiesFromStore);\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return __spreadValues(__spreadValues({}, forwardedCookies), ownCookies);\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nfunction parseWorkerRequest(rawRequest) {\n  const url = new URL(rawRequest.url);\n  const headers = new import_headers_polyfill5.Headers(rawRequest.headers);\n  return new MockedRequest(url, __spreadProps(__spreadValues({}, rawRequest), {\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || \"\"),\n    headers\n  }));\n}\n\n// src/utils/handleRequest.ts\nvar import_until2 = require(\"@open-draft/until\");\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar import_js_levenshtein = __toESM(require(\"js-levenshtein\"));\n\n// src/utils/internal/parseGraphQLRequest.ts\nvar import_graphql = require(\"graphql\");\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find(def => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\":\n      {\n        const query = request.url.searchParams.get(\"query\");\n        const variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          const {\n            query,\n            variables\n          } = request.body;\n          return {\n            query,\n            variables\n          };\n        }\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          const _c = request.body,\n            {\n              operations,\n              map\n            } = _c,\n            files = __objRest(_c, [\"operations\", \"map\"]);\n          const parsedOperations = jsonParse(operations) || {};\n          if (!parsedOperations.query) {\n            return null;\n          }\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n      }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return __spreadProps(__spreadValues({}, request), {\n    body: request.body,\n    headers: request.headers.all()\n  });\n}\n\n// src/utils/logging/prepareResponse.ts\nvar import_headers_polyfill6 = require(\"headers-polyfill\");\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);\n  return __spreadProps(__spreadValues({}, res), {\n    body: parseBody(res.body, responseHeaders)\n  });\n}\n\n// src/utils/matching/matchRequestUrl.ts\nvar import_path_to_regexp = require(\"path-to-regexp\");\nvar import_getCleanUrl = require(\"@mswjs/interceptors/lib/utils/getCleanUrl\");\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n    if (!parameterName) {\n      return expression;\n    }\n    return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nvar import_headers_polyfill8 = require(\"headers-polyfill\");\n\n// src/response.ts\nvar import_headers_polyfill7 = require(\"headers-polyfill\");\n\n// src/utils/internal/compose.ts\nfunction compose() {\n  for (var _len6 = arguments.length, fns = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    fns[_key6] = arguments[_key6];\n  }\n  return function () {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n}\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides) {\n  let defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return async function () {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new import_headers_polyfill7.Headers({\n        \"x-powered-by\": \"msw\"\n      })\n    }, responseOverrides);\n    for (var _len7 = arguments.length, transformers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      transformers[_key7] = arguments[_key7];\n    }\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find(frame => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = __spreadProps(__spreadValues({}, options.info), {\n      callFrame\n    });\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped() {\n    let shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(publicRequest, response, this.ctx);\n    return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx));\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar RESTMethods = /* @__PURE__ */(RESTMethods2 => {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n})(RESTMethods || {});\nvar restContext = __spreadProps(__spreadValues({}, defaultContext), {\n  cookie,\n  body,\n  text,\n  json,\n  xml\n});\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const {\n      method,\n      path\n    } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(`Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`);\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nvar import_outvariant2 = require(\"outvariant\");\nvar field = (fieldName, fieldValue) => {\n  return res => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      [fieldName]: fieldValue\n    });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant2.invariant)(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  (0, import_outvariant2.invariant)(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = __spreadProps(__spreadValues({}, defaultContext), {\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n});\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.variables = variables;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(() => parseGraphQLRequest(request), error2 => console.error(error2.message));\n  }\n  getPublicRequest(request, parsedResult) {\n    return new GraphQLRequest(request, (parsedResult == null ? void 0 : parsedResult.variables) || {});\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), `${requestInfo}`, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref3, _ref4) => {\n    let [leftScore] = _ref3;\n    let [rightScore] = _ref4;\n    return leftScore - rightScore;\n  }).filter(_ref5 => {\n    let [score] = _ref5;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref6 => {\n    let [, handler] = _ref6;\n    return handler;\n  });\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"warn\";\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nvar import_cookies2 = require(\"@mswjs/cookies\");\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add(__spreadProps(__spreadValues({}, request), {\n    url: request.url.toString()\n  }), response2);\n  import_cookies2.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const {\n    handler,\n    response: response2\n  } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(`Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`, response2, handler.info.header, handler.info.callFrame);\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/utils/logging/serializeResponse.ts\nvar import_headers_polyfill9 = require(\"headers-polyfill\");\nfunction serializeResponse(source) {\n  return {\n    status: source.status,\n    statusText: source.statusText,\n    headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(source.headers)),\n    body: source.body\n  };\n}\n\n// src/setupWorker/start/createRequestListener.ts\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    var _a;\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const request = parseWorkerRequest(message.payload);\n    try {\n      await handleRequest(request, context.requestHandlers, options, context.emitter, {\n        transformResponse,\n        onPassthroughResponse() {\n          messageChannel.postMessage(\"NOT_FOUND\");\n        },\n        async onMockedResponse(response2, _ref7) {\n          let {\n            handler,\n            publicRequest,\n            parsedRequest\n          } = _ref7;\n          if (response2.body instanceof ReadableStream) {\n            throw new Error(devUtils.formatMessage('Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'));\n          }\n          const responseInstance = new Response(response2.body, response2);\n          const responseBodyBuffer = await responseInstance.arrayBuffer();\n          const responseBody = response2.body == null ? null : responseBodyBuffer;\n          messageChannel.postMessage(\"MOCK_RESPONSE\", __spreadProps(__spreadValues({}, response2), {\n            body: responseBody\n          }), [responseBodyBuffer]);\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", response3 => {\n              handler.log(publicRequest, serializeResponse(response3), parsedRequest);\n            });\n          }\n        }\n      });\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        messageChannel.postMessage(\"NETWORK_ERROR\", {\n          name: error2.name,\n          message: error2.message\n        });\n        return;\n      }\n      if (error2 instanceof Error) {\n        devUtils.error(`Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`, request.method, request.url, (_a = error2.stack) != null ? _a : error2);\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n}\n\n// src/utils/internal/requestIntegrityCheck.ts\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const {\n    payload: actualChecksum\n  } = await context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n  if (actualChecksum !== \"b3066ef78c2f9090b4ce87e874965995\") {\n    throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"b3066ef78c2f9090b4ce87e874965995\"}).`);\n  }\n  return serviceWorker;\n}\n\n// src/utils/deferNetworkRequestsUntil.ts\nvar import_until3 = require(\"@open-draft/until\");\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  const originalFetch = window.fetch;\n  window.fetch = async function () {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...arguments);\n  };\n}\n\n// src/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const {\n      payload: responseJson\n    } = message;\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n}\n\n// src/setupWorker/start/utils/validateWorkerScope.ts\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(`Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`);\n  }\n}\n\n// src/setupWorker/start/createStartHandler.ts\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(() => requestIntegrityCheck(context, worker));\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(async registration => {\n      const pendingInstance = registration.installing || registration.waiting;\n      if (pendingInstance) {\n        await new Promise(resolve => {\n          pendingInstance.addEventListener(\"statechange\", () => {\n            if (pendingInstance.state === \"activated\") {\n              return resolve();\n            }\n          });\n        });\n      }\n      await enableMocking(context, options).catch(error2 => {\n        throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n      });\n      return registration;\n    });\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\n\n// src/setupWorker/stop/utils/printStopMessage.ts\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  console.log(`%c${devUtils.formatMessage(\"Mocking disabled.\")}`, \"color:orangered;font-weight:bold;\");\n}\n\n// src/setupWorker/stop/createStop.ts\nvar createStop = context => {\n  return function stop() {\n    var _a;\n    if (!context.isMockingEnabled) {\n      devUtils.warn('Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet\n    });\n  };\n};\n\n// src/utils/internal/requestHandlerUtils.ts\nfunction use(currentHandlers) {\n  for (var _len9 = arguments.length, handlers = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    handlers[_key9 - 1] = arguments[_key9];\n  }\n  currentHandlers.unshift(...handlers);\n}\nfunction restoreHandlers(handlers) {\n  handlers.forEach(handler => {\n    handler.markAsSkipped(false);\n  });\n}\nfunction resetHandlers(initialHandlers) {\n  for (var _len10 = arguments.length, nextHandlers = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n    nextHandlers[_key10 - 1] = arguments[_key10];\n  }\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\n}\n\n// src/setupWorker/start/utils/prepareStartHandler.ts\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\nfunction resolveStartOptions(initialOptions) {\n  return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});\n}\nfunction prepareStartHandler(handler, context) {\n  return initialOptions => {\n    context.startOptions = resolveStartOptions(initialOptions);\n    return handler(context.startOptions, initialOptions || {});\n  };\n}\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nvar import_interceptors4 = require(\"@mswjs/interceptors\");\nvar import_fetch3 = require(\"@mswjs/interceptors/lib/interceptors/fetch\");\nvar import_XMLHttpRequest = require(\"@mswjs/interceptors/lib/interceptors/XMLHttpRequest\");\n\n// src/utils/request/createResponseFromIsomorphicResponse.ts\nvar import_interceptors3 = require(\"@mswjs/interceptors\");\nvar noop = () => {\n  throw new Error(\"Not implemented\");\n};\nfunction createResponseFromIsomorphicResponse(response2) {\n  return __spreadProps(__spreadValues({}, response2), {\n    ok: response2.status >= 200 && response2.status < 300,\n    url: \"\",\n    type: \"default\",\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers,\n    body: new ReadableStream(),\n    redirected: response2.headers.get(\"Location\") != null,\n    async text() {\n      return response2.body || \"\";\n    },\n    async json() {\n      return JSON.parse(response2.body || \"\");\n    },\n    async arrayBuffer() {\n      return (0, import_interceptors3.encodeBuffer)(response2.body || \"\");\n    },\n    bodyUsed: false,\n    formData: noop,\n    blob: noop,\n    clone: noop\n  });\n}\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors4.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async request => {\n    const mockedRequest = new MockedRequest(request.url, __spreadProps(__spreadValues({}, request), {\n      body: await request.arrayBuffer()\n    }));\n    const response2 = await handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\n      transformResponse(response3) {\n        return {\n          status: response3.status,\n          statusText: response3.statusText,\n          headers: response3.headers.all(),\n          body: response3.body,\n          delay: response3.delay\n        };\n      },\n      onMockedResponse(_, _ref8) {\n        let {\n          handler,\n          publicRequest,\n          parsedRequest\n        } = _ref8;\n        if (!options.quiet) {\n          context.emitter.once(\"response:mocked\", response3 => {\n            handler.log(publicRequest, serializeResponse(response3), parsedRequest);\n          });\n        }\n      }\n    });\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.on(\"response\", (request, response2) => {\n    if (!request.id) {\n      return;\n    }\n    const browserResponse = createResponseFromIsomorphicResponse(response2);\n    if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n      context.emitter.emit(\"response:mocked\", browserResponse, request.id);\n    } else {\n      context.emitter.emit(\"response:bypass\", browserResponse, request.id);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(context, options);\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n}\n\n// src/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({\n      quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet\n    });\n  };\n}\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function (event) {\n    for (var _len11 = arguments.length, data2 = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      data2[_key11 - 1] = arguments[_key11];\n    }\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/setupWorker/setupWorker.ts\nvar listeners = [];\nfunction setupWorker() {\n  for (var _len12 = arguments.length, requestHandlers = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    requestHandlers[_key12] = arguments[_key12];\n  }\n  requestHandlers.forEach(handler => {\n    if (Array.isArray(handler)) throw new Error(devUtils.formatMessage('Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));\n  });\n  if ((0, import_is_node_process3.isNodeProcess)()) {\n    throw new Error(devUtils.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n  }\n  const emitter = new import_strict_event_emitter.StrictEventEmitter();\n  const publicEmitter = new import_strict_event_emitter.StrictEventEmitter();\n  pipeEvents(emitter, publicEmitter);\n  const context = {\n    isMockingEnabled: false,\n    startOptions: void 0,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(navigator.serviceWorker, \"message\", event => {\n          if (event.source !== context.worker) {\n            return;\n          }\n          const message = event.data;\n          if (!message) {\n            return;\n          }\n          if (message.type === eventType) {\n            callback(event, message);\n          }\n        });\n      },\n      send(type) {\n        var _a;\n        (_a = context.worker) == null ? void 0 : _a.postMessage(type);\n      }\n    },\n    events: {\n      addListener(target, eventType, callback) {\n        target.addEventListener(eventType, callback);\n        listeners.push({\n          eventType,\n          target,\n          callback\n        });\n        return () => {\n          target.removeEventListener(eventType, callback);\n        };\n      },\n      removeAllListeners() {\n        for (const {\n          target,\n          eventType,\n          callback\n        } of listeners) {\n          target.removeEventListener(eventType, callback);\n        }\n        listeners = [];\n      },\n      once(eventType) {\n        const bindings = [];\n        return new Promise((resolve, reject) => {\n          const handleIncomingMessage = event => {\n            try {\n              const message = event.data;\n              if (message.type === eventType) {\n                resolve(message);\n              }\n            } catch (error2) {\n              reject(error2);\n            }\n          };\n          bindings.push(context.events.addListener(navigator.serviceWorker, \"message\", handleIncomingMessage), context.events.addListener(navigator.serviceWorker, \"messageerror\", reject));\n        }).finally(() => {\n          bindings.forEach(unbind => unbind());\n        });\n      }\n    },\n    useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n  };\n  const startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n  const stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n  return {\n    start: prepareStartHandler(startHandler, context),\n    stop() {\n      context.events.removeAllListeners();\n      context.emitter.removeAllListeners();\n      publicEmitter.removeAllListeners();\n      stopHandler();\n    },\n    use() {\n      for (var _len13 = arguments.length, handlers = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        handlers[_key13] = arguments[_key13];\n      }\n      use(context.requestHandlers, ...handlers);\n    },\n    restoreHandlers() {\n      restoreHandlers(context.requestHandlers);\n    },\n    resetHandlers() {\n      for (var _len14 = arguments.length, nextHandlers = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        nextHandlers[_key14] = arguments[_key14];\n      }\n      context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\n    },\n    listHandlers() {\n      return toReadonlyArray(context.requestHandlers);\n    },\n    printHandlers() {\n      const handlers = this.listHandlers();\n      handlers.forEach(handler => {\n        const {\n          header,\n          callFrame\n        } = handler.info;\n        const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n        console.groupCollapsed(`${pragma} ${header}`);\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`);\n        }\n        console.log(\"Handler:\", handler);\n        if (handler instanceof RestHandler) {\n          console.log(\"Match:\", `https://mswjs.io/repl?path=${handler.info.path}`);\n        }\n        console.groupEnd();\n      });\n    },\n    events: {\n      on() {\n        return publicEmitter.on(...arguments);\n      },\n      removeListener() {\n        return publicEmitter.removeListener(...arguments);\n      },\n      removeAllListeners() {\n        return publicEmitter.removeAllListeners(...arguments);\n      }\n    }\n  };\n}\n\n// src/rest.ts\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\" /* HEAD */),\n  get: createRestHandler(\"GET\" /* GET */),\n  post: createRestHandler(\"POST\" /* POST */),\n  put: createRestHandler(\"PUT\" /* PUT */),\n  delete: createRestHandler(\"DELETE\" /* DELETE */),\n  patch: createRestHandler(\"PATCH\" /* PATCH */),\n  options: createRestHandler(\"OPTIONS\" /* OPTIONS */)\n};\n\n// src/graphql.ts\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(operationType, operationName, url, resolver);\n  };\n}\nfunction createGraphQLOperationHandler(url) {\n  return resolver => {\n    return new GraphQLHandler(\"all\", new RegExp(\".*\"), url, resolver);\n  };\n}\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(\"query\", \"*\"),\n  mutation: createScopedGraphQLHandler(\"mutation\", \"*\")\n};\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(\"query\", url),\n    mutation: createScopedGraphQLHandler(\"mutation\", url)\n  };\n}\nvar graphql = __spreadProps(__spreadValues({}, standardGraphQLHandlers), {\n  link: createGraphQLLink\n});\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  GraphQLHandler,\n  MockedRequest,\n  RESTMethods,\n  RequestHandler,\n  RestHandler,\n  cleanUrl,\n  compose,\n  context,\n  createResponseComposition,\n  defaultContext,\n  defaultResponse,\n  graphql,\n  graphqlContext,\n  handleRequest,\n  matchRequestUrl,\n  response,\n  rest,\n  restContext,\n  setupWorker\n});","map":{"version":3,"names":["src_exports","__export","GraphQLHandler","MockedRequest","RESTMethods","RequestHandler","RestHandler","cleanUrl","compose","context","context_exports","createResponseComposition","defaultContext","defaultResponse","graphql","graphqlContext","handleRequest","matchRequestUrl","response","rest","restContext","setupWorker","module","exports","__toCommonJS","body","cookie","data","delay","errors","extensions","fetch","json","set","status","text","xml","import_codes","__toESM","require","statusCode","statusText","res","default","String","import_headers_polyfill","_len","arguments","length","args","Array","_key","name","value","headers","append","objectToHeaders","forEach","value2","name2","cookieUtils","options","serializedCookie","serialize","document","jsonParse","JSON","parse","error2","isObject","isArray","mergeRight","left","right","Object","entries","reduce","result","_ref","key","rightValue","leftValue","concat","assign","body2","stringify","payload","prevBody","nextBody","import_is_node_process","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","isNodeProcess","Math","floor","random","durationOrMode","delayTime","Error","errorsList","import_is_node_process2","import_headers_polyfill2","useFetch","window","augmentRequestInit","requestInit","Headers","__spreadProps","__spreadValues","all","createFetchRequestParameters","input","method","requestParameters","includes","undefined","derivedRequestInit","url","href","import_is_node_process3","import_strict_event_emitter","import_until4","import_until","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","getAbsoluteWorkerUrl","relativeUrl","URL","location","origin","import_outvariant","LIBRARY_PREFIX","formatMessage","message","_len2","positionals","_key2","interpolatedMessage","format","warn","_len3","_key3","console","error","_len4","_key4","devUtils","getWorkerInstance","mockRegistrations","navigator","serviceWorker","getRegistrations","then","registrations","controller","reload","existingRegistration","update","instance","until","register","isWorkerMissing","scopeUrl","scope","printStartMessage","quiet","groupCollapsed","log","workerUrl","workerScope","groupEnd","enableMocking","_a","_b","workerChannel","send","events","once","isMockingEnabled","WorkerChannel","constructor","port","postMessage","event","_len5","rest2","_key5","data2","transfer","type","NetworkError","import_interceptors2","import_headers_polyfill5","cookieUtils3","import_cookies","import_interceptors","import_bufferUtils","import_headers_polyfill4","cookieUtils2","getAllCookies","getRequestCookies","request","credentials","import_headers_polyfill3","parseContentHeaders","headersString","stringToHeaders","contentType","get","disposition","directives","split","acc","chunk","trim","join","slice","filename","parseMultipartData","boundary","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","contentType2","File","parsedValue","parseBody","toLowerCase","hasMultipartContent","toString","hasJsonContent","isStringEqual","actual","expected","IsomorphicRequest","init","id","cache","destination","integrity","keepalive","mode","priority","redirect","referrer","referrerPolicy","cookies","getCookies","text2","decodeBuffer","passthrough","requestCookiesString","ownCookies","store","hydrate","cookiesFromStore","from","_ref2","cookiesFromDocument","forwardedCookies","parseWorkerRequest","rawRequest","encodeBuffer","import_until2","getResponse","handlers","resolutionContext","relevantHandlers","handler","test","executionResult","previousResults","result2","run","shouldSkip","parsedResult","markAsSkipped","Promise","resolve","publicRequest","parsedRequest","import_js_levenshtein","import_graphql","getPublicUrlFromRequest","pathname","protocol","host","parseDocumentNode","node","operationDef","definitions","def","kind","operationType","operation","operationName","parseQuery","query","ast","extractMultipartVariables","variables","files","operations","pathArray","dotPath","lastPath","reversedPaths","reverse","paths","target","path","getGraphQLInput","searchParams","_c","__objRest","parsedOperations","parsedMap","parseGraphQLRequest","requestPublicUrl","getStatusCodeColor","status2","getTimestamp","now","Date","getHours","getMinutes","getSeconds","padStart","prepareRequest","import_headers_polyfill6","prepareResponse","responseHeaders","import_path_to_regexp","import_getCleanUrl","REDUNDANT_CHARACTERS_EXP","getSearchParams","isAbsoluteUrl","getAbsoluteUrl","baseUrl","baseURI","decodeURI","encodeURI","normalizePath","maybeAbsoluteUrl","coercePath","_","parameterName","wildcard","expression","normalizedPath","cleanPath","cleanUrl2","getCleanUrl","match","decode","decodeURIComponent","params","matches","import_headers_polyfill8","import_headers_polyfill7","_len6","fns","_key6","reduceRight","leftFn","rightFn","defaultResponseTransformers","responseOverrides","defaultTransformers","initialResponse","_len7","transformers","_key7","resolvedTransformers","resolvedResponse","networkError","SOURCE_FRAME","BUILD_FRAME","getCallFrame","stack","frames","declarationFrame","frame","declarationPath","isIterable","fn","Symbol","iterator","ctx","resolver","callFrame","info","_request","_resolutionContext","predicate","getPublicRequest","_parsedResult","shouldIntercept","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","done","next","nextResponse","resolverGeneratorResult","response2","RESTMethods2","RestRequest","header","checkRedundantQueryParameters","queryParams","paramName","push","matchesMethod","publicUrl","loggedRequest","loggedResponse","statusColor","import_outvariant2","field","fieldName","fieldValue","validateFieldName","invariant","tryCatch","onException","isDocumentNode","GraphQLRequest","endpoint","resolvedOperationName","parsedNode","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groupHandlersByType","groups","getRestHandlerScore","Infinity","hasSameMethod","methodScoreDelta","score","getGraphQLHandlerScore","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getSuggestedHandler","getScore","suggestedHandlers","suggestions","sort","_ref3","_ref4","leftScore","rightScore","_ref5","_ref6","getSuggestedHandlersMessage","onUnhandledRequest","strategy","parsedGraphQLQuery","generateHandlerSuggestion","handlerGroups","generateUnhandledRequestMessage","requestHeader","handlerSuggestion","messageTemplate","applyStrategy","strategy2","warning","bind","import_cookies2","readResponseCookies","add","persist","emitter","handleRequestOptions","_d","_e","_f","emit","onPassthroughResponse","call","lookupError","lookupResult","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","import_headers_polyfill9","serializeResponse","source","flattenHeadersObject","headersToObject","createRequestListener","messageChannel","ports","requestHandlers","_ref7","ReadableStream","responseInstance","Response","responseBodyBuffer","arrayBuffer","responseBody","response3","requestIntegrityCheck","actualChecksum","import_until3","deferNetworkRequestsUntil","predicatePromise","originalXhrSend","XMLHttpRequest","prototype","_len8","_key8","originalFetch","createResponseListener","responseJson","isMockedResponse","requestId","validateWorkerScope","createStartHandler","start","customOptions","startWorkerInstance","removeAllListeners","on","missingWorkerMessage","addListener","state","clearInterval","keepAliveInterval","integrityError","setInterval","startOptions","workerRegistration","pendingInstance","addEventListener","catch","waitUntilReady","printStopMessage","createStop","stop","use","currentHandlers","_len9","_key9","unshift","restoreHandlers","resetHandlers","initialHandlers","_len10","nextHandlers","_key10","DEFAULT_START_OPTIONS","mockServiceWorkerUrl","resolveStartOptions","initialOptions","prepareStartHandler","import_interceptors4","import_fetch3","import_XMLHttpRequest","import_interceptors3","noop","createResponseFromIsomorphicResponse","ok","redirected","bodyUsed","formData","blob","clone","createFallbackRequestListener","interceptor","BatchInterceptor","interceptors","FetchInterceptor","XMLHttpRequestInterceptor","mockedRequest","_ref8","respondWith","browserResponse","apply","createFallbackStart","fallbackInterceptor","createFallbackStop","dispose","pipeEvents","rawEmit","_isPiped","_len11","_key11","toReadonlyArray","freeze","listeners","_len12","_key12","StrictEventEmitter","publicEmitter","eventType","callback","removeEventListener","bindings","reject","handleIncomingMessage","finally","unbind","useFallbackMode","startHandler","stopHandler","_len13","_key13","_len14","_key14","listHandlers","printHandlers","pragma","hasOwnProperty","removeListener","createRestHandler","head","post","put","delete","patch","createScopedGraphQLHandler","createGraphQLOperationHandler","standardGraphQLHandlers","mutation","createGraphQLLink","link"],"sources":["C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\index.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\index.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\status.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\set.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\cookie.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\body.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\jsonParse.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\isObject.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\mergeRight.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\json.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\data.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\extensions.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\delay.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\errors.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\fetch.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\text.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\xml.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\setupWorker.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createStartHandler.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\getWorkerInstance.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\getWorkerByRegistration.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\getAbsoluteWorkerUrl.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\devUtils.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\printStartMessage.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\enableMocking.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\createMessageChannel.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\NetworkError.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\parseWorkerRequest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\MockedRequest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\getRequestCookies.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\parseMultipartData.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\parseBody.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\isStringEqual.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\handleRequest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\getResponse.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\onUnhandledRequest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\parseGraphQLRequest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\getPublicUrlFromRequest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\getStatusCodeColor.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\getTimestamp.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\prepareRequest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\prepareResponse.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\matching\\matchRequestUrl.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\cleanUrl.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\isAbsoluteUrl.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\getAbsoluteUrl.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\matching\\normalizePath.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\handlers\\RequestHandler.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\response.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\compose.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\getCallFrame.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\isIterable.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\handlers\\RestHandler.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\context\\field.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\tryCatch.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\handlers\\GraphQLHandler.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\readResponseCookies.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\serializeResponse.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createRequestListener.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\requestIntegrityCheck.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\deferNetworkRequestsUntil.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createResponseListener.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\validateWorkerScope.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\stop\\utils\\printStopMessage.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\stop\\createStop.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\requestHandlerUtils.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\prepareStartHandler.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createFallbackRequestListener.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\createResponseFromIsomorphicResponse.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createFallbackStart.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\stop\\createFallbackStop.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\pipeEvents.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\toReadonlyArray.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\rest.ts","C:\\Users\\nicol\\Desktop\\poroyecto\\fe3-final-main (1)\\fe3-final-main\\node_modules\\msw\\src\\graphql.ts"],"sourcesContent":["import * as context from './context'\nexport { context }\n\nexport { setupWorker } from './setupWorker/setupWorker'\nexport {\n  response,\n  defaultResponse,\n  createResponseComposition,\n} from './response'\n\n/* Request handlers */\nexport { RequestHandler, defaultContext } from './handlers/RequestHandler'\nexport { rest } from './rest'\nexport { RestHandler, RESTMethods, restContext } from './handlers/RestHandler'\nexport { graphql } from './graphql'\nexport { GraphQLHandler, graphqlContext } from './handlers/GraphQLHandler'\n\n/* Utils */\nexport { matchRequestUrl } from './utils/matching/matchRequestUrl'\nexport { compose } from './utils/internal/compose'\nexport * from './utils/handleRequest'\nexport { cleanUrl } from './utils/url/cleanUrl'\n\n/**\n * Type definitions.\n */\nexport type { SetupWorkerApi, StartOptions } from './setupWorker/glossary'\nexport type { SharedOptions } from './sharedOptions'\n\nexport * from './utils/request/MockedRequest'\nexport type {\n  ResponseResolver,\n  ResponseResolverReturnType,\n  AsyncResponseResolverReturnType,\n  DefaultBodyType,\n  DefaultRequestMultipartBody,\n} from './handlers/RequestHandler'\n\nexport type {\n  MockedResponse,\n  ResponseTransformer,\n  ResponseComposition,\n  ResponseCompositionOptions,\n  ResponseFunction,\n} from './response'\n\nexport type {\n  RestRequest,\n  RestContext,\n  RequestQuery,\n  ParsedRestRequest,\n} from './handlers/RestHandler'\n\nexport type {\n  GraphQLContext,\n  GraphQLVariables,\n  GraphQLRequest,\n  GraphQLRequestBody,\n  GraphQLJsonRequestBody,\n} from './handlers/GraphQLHandler'\n\nexport type { Path, PathParams, Match } from './utils/matching/matchRequestUrl'\nexport type { DelayMode } from './context/delay'\nexport { ParsedGraphQLRequest } from './utils/internal/parseGraphQLRequest'\n","export { status } from './status'\nexport { set } from './set'\nexport { cookie } from './cookie'\nexport { body } from './body'\nexport { data } from './data'\nexport { extensions } from './extensions'\nexport { delay } from './delay'\nexport { errors } from './errors'\nexport { fetch } from './fetch'\nexport { json } from './json'\nexport { text } from './text'\nexport { xml } from './xml'\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<N>]\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<CookieName>]\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import type { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess() ? require('node-fetch') : window.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport {\n  SetupWorkerInternalContext,\n  SetupWorkerApi,\n  ServiceWorkerIncomingEventsMap,\n  WorkerLifecycleEventsMap,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport * as requestHandlerUtils from '../utils/internal/requestHandlerUtils'\nimport { ServiceWorkerMessage } from './start/utils/createMessageChannel'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { RestHandler } from '../handlers/RestHandler'\nimport { prepareStartHandler } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { pipeEvents } from '../utils/internal/pipeEvents'\nimport { toReadonlyArray } from '../utils/internal/toReadonlyArray'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListener\n}\n\n// Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\nlet listeners: Listener[] = []\n\n/**\n * Creates a new mock Service Worker registration\n * with the given request handlers.\n * @param {RequestHandler[]} requestHandlers List of request handlers\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\n */\nexport function setupWorker(\n  ...requestHandlers: RequestHandler[]\n): SetupWorkerApi {\n  requestHandlers.forEach((handler) => {\n    if (Array.isArray(handler))\n      throw new Error(\n        devUtils.formatMessage(\n          'Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).',\n        ),\n      )\n  })\n\n  // Error when attempting to run this function in a Node.js environment.\n  if (isNodeProcess()) {\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n  }\n\n  const emitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  const publicEmitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  pipeEvents(emitter, publicEmitter)\n\n  const context: SetupWorkerInternalContext = {\n    // Mocking is not considered enabled until the worker\n    // signals back the successful activation event.\n    isMockingEnabled: false,\n    startOptions: undefined,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(\n          navigator.serviceWorker,\n          'message',\n          (event: MessageEvent) => {\n            // Avoid messages broadcasted from unrelated workers.\n            if (event.source !== context.worker) {\n              return\n            }\n\n            const message = event.data as ServiceWorkerMessage<\n              typeof eventType,\n              any\n            >\n\n            if (!message) {\n              return\n            }\n\n            if (message.type === eventType) {\n              callback(event, message)\n            }\n          },\n        )\n      },\n      send(type) {\n        context.worker?.postMessage(type)\n      },\n    },\n    events: {\n      addListener(\n        target: EventTarget,\n        eventType: string,\n        callback: EventListener,\n      ) {\n        target.addEventListener(eventType, callback)\n        listeners.push({ eventType, target, callback })\n\n        return () => {\n          target.removeEventListener(eventType, callback)\n        }\n      },\n      removeAllListeners() {\n        for (const { target, eventType, callback } of listeners) {\n          target.removeEventListener(eventType, callback)\n        }\n        listeners = []\n      },\n      once(eventType) {\n        const bindings: Array<() => void> = []\n\n        return new Promise<\n          ServiceWorkerMessage<\n            typeof eventType,\n            ServiceWorkerIncomingEventsMap[typeof eventType]\n          >\n        >((resolve, reject) => {\n          const handleIncomingMessage = (event: MessageEvent) => {\n            try {\n              const message = event.data\n\n              if (message.type === eventType) {\n                resolve(message)\n              }\n            } catch (error) {\n              reject(error)\n            }\n          }\n\n          bindings.push(\n            context.events.addListener(\n              navigator.serviceWorker,\n              'message',\n              handleIncomingMessage,\n            ),\n            context.events.addListener(\n              navigator.serviceWorker,\n              'messageerror',\n              reject,\n            ),\n          )\n        }).finally(() => {\n          bindings.forEach((unbind) => unbind())\n        })\n      },\n    },\n    useFallbackMode:\n      !('serviceWorker' in navigator) || location.protocol === 'file:',\n  }\n\n  const startHandler = context.useFallbackMode\n    ? createFallbackStart(context)\n    : createStartHandler(context)\n  const stopHandler = context.useFallbackMode\n    ? createFallbackStop(context)\n    : createStop(context)\n\n  return {\n    start: prepareStartHandler(startHandler, context),\n    stop() {\n      context.events.removeAllListeners()\n      context.emitter.removeAllListeners()\n      publicEmitter.removeAllListeners()\n      stopHandler()\n    },\n\n    use(...handlers) {\n      requestHandlerUtils.use(context.requestHandlers, ...handlers)\n    },\n\n    restoreHandlers() {\n      requestHandlerUtils.restoreHandlers(context.requestHandlers)\n    },\n\n    resetHandlers(...nextHandlers) {\n      context.requestHandlers = requestHandlerUtils.resetHandlers(\n        requestHandlers,\n        ...nextHandlers,\n      )\n    },\n\n    listHandlers() {\n      return toReadonlyArray(context.requestHandlers)\n    },\n\n    printHandlers() {\n      const handlers = this.listHandlers()\n\n      handlers.forEach((handler) => {\n        const { header, callFrame } = handler.info\n        const pragma = handler.info.hasOwnProperty('operationType')\n          ? '[graphql]'\n          : '[rest]'\n\n        console.groupCollapsed(`${pragma} ${header}`)\n\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`)\n        }\n\n        console.log('Handler:', handler)\n\n        if (handler instanceof RestHandler) {\n          console.log(\n            'Match:',\n            `https://mswjs.io/repl?path=${handler.info.path}`,\n          )\n        }\n\n        console.groupEnd()\n      })\n    },\n\n    events: {\n      on(...args) {\n        return publicEmitter.on(...args)\n      },\n      removeListener(...args) {\n        return publicEmitter.removeListener(...args)\n      },\n      removeAllListeners(...args) {\n        return publicEmitter.removeAllListeners(...args)\n      },\n    },\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { requestIntegrityCheck } from '../../utils/internal/requestIntegrityCheck'\nimport { deferNetworkRequestsUntil } from '../../utils/deferNetworkRequestsUntil'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { devUtils } from '../../utils/internal/devUtils'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker is the latest published one\n      const [integrityError] = await until(() =>\n        requestIntegrityCheck(context, worker),\n      )\n\n      if (integrityError) {\n        devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `)\n      }\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration)\n    }\n\n    return workerRegistration\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\nimport { getAbsoluteWorkerUrl } from '../../../utils/url/getAbsoluteWorkerUrl'\nimport { devUtils } from '../../../utils/internal/devUtils'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const [error, instance] = await until<ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (error) {\n    const isWorkerMissing = error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        error.message,\n      ),\n    )\n  }\n\n  return instance\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport const getWorkerByRegistration = (\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null => {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const existingStates = allStates.filter(Boolean) as ServiceWorker[]\n  const mockWorker = existingStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return mockWorker || null\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(relativeUrl: string): string {\n  return new URL(relativeUrl, location.origin).href\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n","import {\n  SerializedResponse,\n  ServiceWorkerIncomingEventsMap,\n} from '../../glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\ninterface WorkerChannelEventsMap {\n  MOCK_RESPONSE: [data: SerializedResponse<any>, body?: [ArrayBuffer]]\n  NOT_FOUND: []\n  NETWORK_ERROR: [data: { name: string; message: string }]\n}\n\nexport class WorkerChannel {\n  constructor(private readonly port: MessagePort) {}\n\n  public postMessage<Event extends keyof WorkerChannelEventsMap>(\n    event: Event,\n    ...rest: WorkerChannelEventsMap[Event]\n  ): void {\n    const [data, transfer] = rest\n    this.port.postMessage({ type: event, data }, { transfer })\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","import { encodeBuffer } from '@mswjs/interceptors'\nimport { Headers } from 'headers-polyfill'\nimport { ServiceWorkerIncomingRequest } from '../../setupWorker/glossary'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Converts a given request received from the Service Worker\n * into a `MockedRequest` instance.\n */\nexport function parseWorkerRequest(\n  rawRequest: ServiceWorkerIncomingRequest,\n): MockedRequest {\n  const url = new URL(rawRequest.url)\n  const headers = new Headers(rawRequest.headers)\n\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: encodeBuffer(rawRequest.body || ''),\n    headers,\n  })\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils'\nimport { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: StrictEventEmitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  • ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import type { DefaultBodyType } from '../../handlers/RequestHandler.js'\nimport type { MockedRequest } from '../request/MockedRequest.js'\n\nexport interface LoggedRequest {\n  id: string\n  url: URL\n  method: string\n  headers: Record<string, string>\n  cookies: Record<string, string>\n  body: DefaultBodyType\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest): LoggedRequest {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<any>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  return {\n    ...res,\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders),\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType extends DefaultBodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType extends DefaultBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType extends DefaultBodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType extends DefaultBodyType = any> =\n  ResponseFunction<BodyType> & {\n    /**\n     * Respond using a given mocked response to the first captured request.\n     * Does not affect any subsequent captured requests.\n     */\n    once: ResponseFunction<BodyType>\n    networkError: (message: string) => void\n  }\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType extends DefaultBodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport type { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse<any>) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(request: MockedRequest, public readonly variables: Variables) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(request, parsedResult?.variables || {})\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import { flattenHeadersObject, headersToObject } from 'headers-polyfill'\nimport type { SerializedResponse } from '../../setupWorker/glossary'\n\nexport function serializeResponse(source: Response): SerializedResponse<any> {\n  return {\n    status: source.status,\n    statusText: source.statusText,\n    headers: flattenHeadersObject(headersToObject(source.headers)),\n    body: source.body,\n  }\n}\n","import {\n  StartOptions,\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../glossary'\nimport {\n  ServiceWorkerMessage,\n  WorkerChannel,\n} from './utils/createMessageChannel'\nimport { NetworkError } from '../../utils/NetworkError'\nimport { parseWorkerRequest } from '../../utils/request/parseWorkerRequest'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { RequiredDeep } from '../../typeUtils'\nimport { MockedResponse } from '../../response'\nimport { devUtils } from '../../utils/internal/devUtils'\nimport { serializeResponse } from '../../utils/logging/serializeResponse'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const messageChannel = new WorkerChannel(event.ports[0])\n    const request = parseWorkerRequest(message.payload)\n\n    try {\n      await handleRequest<SerializedResponse>(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage('NOT_FOUND')\n          },\n          async onMockedResponse(\n            response,\n            { handler, publicRequest, parsedRequest },\n          ) {\n            if (response.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  'Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.',\n                ),\n              )\n            }\n\n            const responseInstance = new Response(response.body, response)\n            const responseBodyBuffer = await responseInstance.arrayBuffer()\n\n            // If the mocked response has no body, keep it that way.\n            // Sending an empty \"ArrayBuffer\" to the worker will cause\n            // the worker constructing \"new Response(new ArrayBuffer(0))\"\n            // which will throw on responses that must have no body (i.e. 204).\n            const responseBody =\n              response.body == null ? null : responseBodyBuffer\n\n            messageChannel.postMessage(\n              'MOCK_RESPONSE',\n              {\n                ...response,\n                body: responseBody,\n              },\n              [responseBodyBuffer],\n            )\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', (response) => {\n                handler.log(\n                  publicRequest,\n                  serializeResponse(response),\n                  parsedRequest,\n                )\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        messageChannel.postMessage('NETWORK_ERROR', {\n          name: error.name,\n          message: error.message,\n        })\n\n        return\n      }\n\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        messageChannel.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n\nfunction transformResponse(\n  response: MockedResponse<string>,\n): SerializedResponse<string> {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers.all(),\n    body: response.body,\n    delay: response.delay,\n  }\n}\n","import { SetupWorkerInternalContext } from '../../setupWorker/glossary'\n\nexport async function requestIntegrityCheck(\n  context: SetupWorkerInternalContext,\n  serviceWorker: ServiceWorker,\n): Promise<ServiceWorker> {\n  // Signal Service Worker to report back its integrity\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload: actualChecksum } = await context.events.once(\n    'INTEGRITY_CHECK_RESPONSE',\n  )\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n  if (actualChecksum !== SERVICE_WORKER_CHECKSUM) {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${SERVICE_WORKER_CHECKSUM}).`,\n    )\n  }\n\n  return serviceWorker\n}\n","import { until } from '@open-draft/until'\n\n/**\n * Intercepts and defers any requests on the page\n * until the Service Worker instance is ready.\n * Must only be used in a browser.\n */\nexport function deferNetworkRequestsUntil(predicatePromise: Promise<any>) {\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send\n  window.XMLHttpRequest.prototype.send = function (\n    ...args: Parameters<XMLHttpRequest['send']>\n  ) {\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend\n      this.send(...args)\n    })\n  }\n\n  // Defer any `fetch` requests until the Service Worker is ready.\n  const originalFetch = window.fetch\n  window.fetch = async (...args) => {\n    await until(() => predicatePromise)\n    window.fetch = originalFetch\n    return window.fetch(...args)\n  }\n}\n","import {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../../setupWorker/glossary'\nimport { ServiceWorkerMessage } from './utils/createMessageChannel'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response = new Response(responseJson.body || null, responseJson)\n    const isMockedResponse = response.headers.get('x-powered-by') === 'msw'\n\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId)\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId)\n    }\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n","import { devUtils } from '../../utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { RequestHandler } from '../../handlers/RequestHandler'\n\nexport function use(\n  currentHandlers: RequestHandler[],\n  ...handlers: RequestHandler[]\n): void {\n  currentHandlers.unshift(...handlers)\n}\n\nexport function restoreHandlers(handlers: RequestHandler[]): void {\n  handlers.forEach((handler) => {\n    handler.markAsSkipped(false)\n  })\n}\n\nexport function resetHandlers(\n  initialHandlers: RequestHandler[],\n  ...nextHandlers: RequestHandler[]\n) {\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers]\n}\n","import { RequiredDeep } from '../../../typeUtils'\nimport { mergeRight } from '../../../utils/internal/mergeRight'\nimport {\n  SetupWorkerApi,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorkerApi['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest'\nimport {\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  StartOptions,\n} from '../glossary'\nimport type { RequiredDeep } from '../../typeUtils'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { MockedRequest } from '../../utils/request/MockedRequest'\nimport { serializeResponse } from '../../utils/logging/serializeResponse'\nimport { createResponseFromIsomorphicResponse } from '../../utils/request/createResponseFromIsomorphicResponse'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer(),\n    })\n\n    const response = await handleRequest<SerializedResponse>(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response) {\n          return {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers.all(),\n            body: response.body,\n            delay: response.delay,\n          }\n        },\n        onMockedResponse(_, { handler, publicRequest, parsedRequest }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', (response) => {\n              handler.log(\n                publicRequest,\n                serializeResponse(response),\n                parsedRequest,\n              )\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.on('response', (request, response) => {\n    if (!request.id) {\n      return\n    }\n\n    const browserResponse = createResponseFromIsomorphicResponse(response)\n\n    if (response.headers.get('x-powered-by') === 'msw') {\n      context.emitter.emit('response:mocked', browserResponse, request.id)\n    } else {\n      context.emitter.emit('response:bypass', browserResponse, request.id)\n    }\n  })\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { encodeBuffer, IsomorphicResponse } from '@mswjs/interceptors'\n\nconst noop = () => {\n  throw new Error('Not implemented')\n}\n\nexport function createResponseFromIsomorphicResponse(\n  response: IsomorphicResponse,\n): Response {\n  return {\n    ...response,\n    ok: response.status >= 200 && response.status < 300,\n    url: '',\n    type: 'default',\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers,\n    body: new ReadableStream(),\n    redirected: response.headers.get('Location') != null,\n    async text() {\n      return response.body || ''\n    },\n    async json() {\n      return JSON.parse(response.body || '')\n    },\n    async arrayBuffer() {\n      return encodeBuffer(response.body || '')\n    },\n    bodyUsed: false,\n    formData: noop,\n    blob: noop,\n    clone: noop,\n  }\n}\n","import { createFallbackRequestListener } from './createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n","import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { EventEmitter } from 'stream'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents(\n  source: EventEmitter,\n  destination: EventEmitter,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","import { DefaultBodyType, ResponseResolver } from './handlers/RequestHandler'\nimport {\n  RESTMethods,\n  RestContext,\n  RestHandler,\n  RestRequest,\n} from './handlers/RestHandler'\nimport { Path, PathParams } from './utils/matching/matchRequestUrl'\n\nfunction createRestHandler<Method extends RESTMethods | RegExp>(\n  method: Method,\n) {\n  return <\n    RequestBodyType extends DefaultBodyType = DefaultBodyType,\n    Params extends PathParams<keyof Params> = PathParams,\n    ResponseBody extends DefaultBodyType = DefaultBodyType,\n  >(\n    path: Path,\n    resolver: ResponseResolver<\n      RestRequest<\n        Method extends RESTMethods.HEAD | RESTMethods.GET\n          ? never\n          : RequestBodyType,\n        Params\n      >,\n      RestContext,\n      ResponseBody\n    >,\n  ) => {\n    return new RestHandler(method, path, resolver)\n  }\n}\n\nexport const rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(RESTMethods.HEAD),\n  get: createRestHandler(RESTMethods.GET),\n  post: createRestHandler(RESTMethods.POST),\n  put: createRestHandler(RESTMethods.PUT),\n  delete: createRestHandler(RESTMethods.DELETE),\n  patch: createRestHandler(RESTMethods.PATCH),\n  options: createRestHandler(RESTMethods.OPTIONS),\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { ResponseResolver } from './handlers/RequestHandler'\nimport {\n  GraphQLHandler,\n  GraphQLContext,\n  GraphQLRequest,\n  GraphQLVariables,\n  ExpectedOperationTypeNode,\n  GraphQLHandlerNameSelector,\n} from './handlers/GraphQLHandler'\nimport { Path } from './utils/matching/matchRequestUrl'\n\nexport interface TypedDocumentNode<\n  Result = { [key: string]: any },\n  Variables = { [key: string]: any },\n> extends DocumentNode {\n  __apiType?: (variables: Variables) => Result\n  __resultType?: Result\n  __variablesType?: Variables\n}\n\nfunction createScopedGraphQLHandler(\n  operationType: ExpectedOperationTypeNode,\n  url: Path,\n) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    operationName:\n      | GraphQLHandlerNameSelector\n      | DocumentNode\n      | TypedDocumentNode<Query, Variables>,\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      operationType,\n      operationName,\n      url,\n      resolver,\n    )\n  }\n}\n\nfunction createGraphQLOperationHandler(url: Path) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      'all',\n      new RegExp('.*'),\n      url,\n      resolver,\n    )\n  }\n}\n\nconst standardGraphQLHandlers = {\n  /**\n   * Captures any GraphQL operation, regardless of its name, under the current scope.\n   * @example\n   * graphql.operation((req, res, ctx) => {\n   *   return res(ctx.data({ name: 'John' }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/operation `graphql.operation()`}\n   */\n  operation: createGraphQLOperationHandler('*'),\n\n  /**\n   * Captures a GraphQL query by a given name.\n   * @example\n   * graphql.query('GetUser', (req, res, ctx) => {\n   *   return res(ctx.data({ user: { name: 'John' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/query `graphql.query()`}\n   */\n  query: createScopedGraphQLHandler('query' as OperationTypeNode, '*'),\n\n  /**\n   * Captures a GraphQL mutation by a given name.\n   * @example\n   * graphql.mutation('SavePost', (req, res, ctx) => {\n   *   return res(ctx.data({ post: { id: 'abc-123' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/mutation `graphql.mutation()`}\n   */\n  mutation: createScopedGraphQLHandler('mutation' as OperationTypeNode, '*'),\n}\n\nfunction createGraphQLLink(url: Path): typeof standardGraphQLHandlers {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler('query' as OperationTypeNode, url),\n    mutation: createScopedGraphQLHandler('mutation' as OperationTypeNode, url),\n  }\n}\n\nexport const graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}